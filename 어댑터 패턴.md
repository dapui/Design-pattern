# 어댑터 패턴 (Adapter Pattern)

## 어댑터 패턴이란?

> **호환되지 않는 인터페이스를 가진 객체들이 함께 동작할 수 있도록 중간에서 변환해주는 구조 패턴**

간단히 말해, 서로 맞지 않는 두 개의 퍼즐 조각을 연결해주는 **중간 연결고리** 역할을 합니다.

## 구조

### 객체 어댑터 (가장 일반적)

```
┌─────────────┐
│  Client     │
└──────┬──────┘
       │
       ▼
┌─────────────────┐
│ Interface       │
│  Target         │
└─────────────────┘
       △
       │
┌──────┴──────────┐
│ Adapter         │
└──────┬──────────┘
       │
       ▼
┌──────────┐
│ Adaptee  │
└──────────┘
```

### 주요 구성 요소

- **Target**: 클라이언트가 사용하는 인터페이스
- **Adapter**: 변환을 담당하는 중간 클래스
- **Adaptee**: 실제로 사용하고 싶은 기존 클래스 (호환 안 됨)
- **Client**: 어댑터를 통해 Adaptee를 사용

---

## 코드 예시

```java
// 1. Target 인터페이스 (우리가 사용하는 표준)
public interface PaymentService {
    void pay(int amount);
}

// 2. 기존 구현체
public class CardPaymentService implements PaymentService {
    @Override
    public void pay(int amount) {
        System.out.println("카드 결제: " + amount + "원");
    }
}
public class KakaoPayService implements PaymentService {
    @Override
    public void pay(int amount) {
        System.out.println("카카오페이 결제: " + amount + "원");
    }
}
```

```java
// 2. Adaptee (외부 라이브러리)
public class ForeignPgPayment {
    public boolean execute(double usdAmount, String currency) {
        System.out.println("PG 결제: " + usdAmount + " " + currency);
        return true;
    }
}
```

### 문제점 (수정 불가)

- 메서드 이름이 다름.
- 금액 타입이 다름.
- currency 개념 추가.
- 인터페이스 구현 불가.

```java
// 3. 어댑터 없이 코드를 작성할 경우.
public class PaymentProcessor {

    public void process(String type, int amount) {
        if (type.equals("CARD")) {
            new CardPaymentService().pay(amount);
        } else if (type.equals("KAKAO")) {
            new KakaoPayService().pay(amount);
        } else if (type.equals("FOREIGN_PG")) {
            ForeignPgPayment pg = new ForeignPgPayment();
            pg.execute(amount, "KRW");
        }
    }
}
```

### 어댑터 없을 경우 문제

- if-else 가 많아져 가독성이 떨어짐.
- 결제 수단 추가할 때마다 수정

```java
// 4. 어댑터 생성
public class ForeignPgPaymentAdapter implements PaymentService {

  private final ForeignPgPayment pgPayment;

  public ForeignPgPaymentAdapter(ForeignPgPayment pgPayment) {
      this.pgPayment = pgPayment;
  }

  @Override
  public void pay(int amount) {
      double krw = amount;
      pgPayment.execute(krw, "KRW");
  }
}

// 5. PaymentProcessor 수정 (adapter 적용)
public class PaymentProcessor {
  private final Map<String, PaymentService> paymentMap;

  public PaymentProcessor() {
      paymentMap = Map.of(
              "CARD", new CardPaymentService(),
              "KAKAO", new KakaoPayService(),
              "FOREIGN_PG", new ForeignPgPaymentAdapter(new ForeignPgPayment())
      );
  }

  public void process(String type, int amount) {
      paymentMap.get(type).pay(amount);
  }
}

// 6. 사용
public class Client {
  public static void main(String[] args) {
    PaymentProcessor paymentProcessor = new PaymentProcessor();

    paymentProcessor.process("CARD", 10000);
    paymentProcessor.process("KAKAO", 10000);
    paymentProcessor.process("PG", 10000);
  }
}
```

## 장단점

### 장점

1. **단일 책임 원칙 (SRP)**

   - 인터페이스 변환 로직을 별도 클래스로 분리

2. **개방-폐쇄 원칙 (OCP)**

   - 기존 코드 수정 없이 새로운 어댑터 추가 가능

3. **코드 재사용성**

   - 기존 클래스를 수정하지 않고 재사용

4. **유연성**
   - 여러 어댑터를 쉽게 교체 가능

### 단점

1. **복잡도 증가**

   - 새로운 인터페이스와 클래스 추가로 코드 복잡도 상승

2. **성능 오버헤드**

   - 어댑터를 거치는 과정에서 약간의 성능 저하 가능

3. **과도한 사용**
   - 간단한 변환에도 어댑터를 만들면 오히려 비효율적

---

## 사용하면 좋은 경우

1. **외부 라이브러리 통합**

   ```
   서드파티 API를 내 시스템 인터페이스에 맞춰 사용하고 싶을 때
   ```

2. **레거시 코드 재사용**

   ```
   오래된 코드를 수정하지 않고 새 시스템에서 사용하고 싶을 때
   ```

3. **인터페이스 불일치**

   ```
   이미 만들어진 클래스인데 필요한 인터페이스가 다를 때
   ```

4. **여러 구현체 통합**
   ```
   비슷한 기능이지만 다른 인터페이스를 가진 여러 클래스를
   하나의 인터페이스로 통일하고 싶을 때
   ```

### 실제 사용 사례

- 결제 게이트웨이 통합 (Stripe, PayPal, Toss 등)
- 데이터베이스 드라이버 (MySQL, PostgreSQL, MongoDB 등)
- 로깅 시스템 (Winston, Log4j, 커스텀 로거 등)
- 클라우드 스토리지 (AWS S3, Google Cloud, Azure 등)

---

## 핵심 정리

```
어댑터 패턴 = 인터페이스 변환기

[호환 안 되는 것] -> [어댑터] -> [호환됨]

장점: 재사용성,유연성
단점: 복잡함
```
