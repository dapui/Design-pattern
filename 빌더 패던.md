결론

빌더 패턴은 **생성자에서 인자가 많을때 고려해볼 수 있는 패턴 ,** 필드의 변경이 적으며 필수 값이 적은(옵션값이 많은) 엔티티 나 DTO에 사용하면 매우 유용할것으로 보인다.  롬복을 사용하여 자동으로 사용할 수 있지만 컬렉션의 기능이 완벽치 않아(정확치 않음) 사용이 제한될 수 있다.

빌더 패턴(Builder Pattern)은 복잡한 객체의 생성 과정과 표현 방법을 분리하여 다양한 구성의 인스턴스를 만드는 생성 패턴이다.

생성자에 들어갈 매개 변수를 메서드로 하나하나 받아들이고 마지막에 통합 빌드해서 객체를 생성하는 방식이다. 

예를 들어 수제 햄버거를 들 수 있다. 수제 햄버거를 주문할때 빵이나 패티 등 속재료들은 주문하는 사람이 마음대로 결정된다. 어느 사람은 치즈를 빼달라고 할수 있고 어느 사람은 토마토를 빼달라고 할수 있다. 이처럼 선택적 속재료들을 보다 유연하게 받아 다양한 타입의 인스턴스를 생성할수 있어, 클래스의 선택적 매개변수가 많은 상황에서 유용하게 사용된다.

![예제1_수제버거.png](attachment:7caa7059-c64d-4ffb-aed3-352b27c3261a:예제1_수제버거.png)

위의 내용을 코드로 표현해 보면

```jsx
class Hamburger {
    // 필수 매개변수
    private int bun;
    private int patty;

    // 선택 매개변수
    private int cheese;
    private int lettuce;
    private int tomato;
    private int bacon;

    public Hamburger(int bun, int patty, int cheese, int lettuce, int tomato, int bacon) {
        this.bun = bun;
        this.patty = patty;
        this.cheese = cheese;
        this.lettuce = lettuce;
        this.tomato = tomato;
        this.bacon = bacon;
    }

    public Hamburger(int bun, int patty, int cheese, int lettuce, int tomato) {
        this.bun = bun;
        this.patty = patty;
        this.cheese = cheese;
        this.lettuce = lettuce;
        this.tomato = tomato;
    }
    

    public Hamburger(int bun, int patty, int cheese, int lettuce) {
        this.bun = bun;
        this.patty = patty;
        this.cheese = cheese;
        this.lettuce = lettuce;
    }

    public Hamburger(int bun, int patty, int cheese) {
        this.bun = bun;
        this.patty = patty;
        this.cheese = cheese;
    }

    ...
}

```

사용자 코드

```jsx
public static void main(String[] args) {
    // 모든 재료가 있는 햄버거
    Hamburger hamburger1 = new Hamburger(2, 1, 2, 4, 6, 8);

    // 빵과 패티 치즈만 있는 햄버거
    Hamburger hamburger2 = new Hamburger(2, 1, 1);

    // 빵과 패티 베이컨만 있는 햄버거
    Hamburger hamburger3 = new Hamburger(2, 0, 0, 0, 0, 6);
}

```

코드를 보면 알다시피 매게 변수의 갯수에 따라사  생성자가 필요하다.

또한 생성자의 들어갈 인자가 어떤것인지 파악하기도 어렵다.

이처럼 타입이 다양할 수록 생성자 메서드 수가 기하급수적으로 늘어나 가독성이나 유지보수 측면에서 좋지 않다.

※위의 코드 방식을 **점층적 생성자 패턴**이라 한다.

이러한 단점을 보완하기 위해  Setter 메소드를 사용한 **자바 빈 패턴**이 고안되었다.  매개변수가 없는 생성자로 객체 생성후 Setter 메소드를 이용해 클래스 필드의 초깃값을

설정하는 방식이다.

```jsx
class Hamburger {
    // 필수 매개변수
    private int bun;
    private int patty;

    // 선택 매개변수
    private int cheese;
    private int lettuce;
    private int tomato;
    private int bacon;
    
    public Hamburger() {}

    public void setBun(int bun) {
        this.bun = bun;
    }

    public void setPatty(int patty) {
        this.patty = patty;
    }

    public void setCheese(int cheese) {
        this.cheese = cheese;
    }

    public void setLettuce(int lettuce) {
        this.lettuce = lettuce;
    }

    public void setTomato(int tomato) {
        this.tomato = tomato;
    }

    public void setBacon(int bacon) {
        this.bacon = bacon;
    }

```

사용자 코드

```jsx
public static void main(String[] args) {
    // 모든 재료가 있는 햄버거
    Hamburger hamburger1 = new Hamburger();
    hamburger1.setBun(2);
    hamburger1.setPatty(1);
    hamburger1.setCheese(2);
    hamburger1.setLettuce(4);
    hamburger1.setTomato(6);
    hamburger1.setBacon(8);

    // 빵과 패티 치즈만 있는 햄버거
    Hamburger hamburger2 = new Hamburger();
    hamburger2.setBun(2);
    hamburger2.setPatty(1);
    hamburger2.setCheese(2);

    // 빵과 패티 베이컨만 있는 햄버거
    Hamburger hamburger3 = new Hamburger();
    hamburger3.setBun(2);
    hamburger2.setPatty(1);
    hamburger3.setBacon(8);
}
```

기존 생성자 오버로딩에서 나타났던 가독성 문제점이 사라지고 선택적인 파라미터에 대해 해당되는 Setter 메서드를 호출함으로써 유연적으로 객체 생성이 가능해졌다.

하지만 이런한 방식을 객체 생성 시점에 모든 값을 주입하지 않아 일관성 문제와 불변성 문제가 나타나게 된다.

1. 일관성 문제

필수 매게변수란 객체가 초기화될때 반드시 설정되어야 하는값이다. 하지만 개발자가 깜빡하고 setBus() 이나 setPatty() 메서드를 호출하지 않았다면 이 객체는 일관성이 무너진

상태가 된다. 즉 객체가 유효하지 않는 것이다. 만일 다른곳에서 햄버거 인스턴스를 사용하게 된다면 런타임 예외가 발생할 수도 있다.

이는 객체를 생성하는 부분과 값을 설정하는 부분이 물리적으로 떨어져 있어서 발생하는 문제점ㅇ.다. 물론 이는 어느정도 생성자와 결합하여 극복은 할수 있다. 하지만 다음에 소개할 불변성의 문제 때문에 자바진즈 패턴은 지양해야 한다.

1. 불변성 문제

자바 빈즈 패턴의  Setter 메서드는 객체를 처음 생성할때 필드값을 설정하기 위해 존재하는 메서드이다. 하지만 객체를 생성햇음에도 여전희 외부적으로 Setter 메서드를 호출해 함부로 객체를 조작할수 있게 된다. 이것을 불변함을 보장 할수 없다고 얘기한다.

마치 완성된 햄버거에 중간에 치즈를 교체하낟고 햄버거를 막 분리하는 것과 같은 이치이다.

빌더패턴은 이러한 문제들을 해결하기 위해 별도의 Builder 클래스를 만들어 메소드를 통해 step-by-step으로 값을 입력 받은 후에 최종적으로  build() 메소드로 하나의 인스턴스를 생성하여 리턴하는 패턴이다.

빌더 패턴 사용법을 잠시 살펴보면 HamburgerBuilder 빌더 클래스의 메서드채이닝(Chaining)형태로 호출함으로써 자연스럽게 인스턴스를 구성하고 마지막에 build() 메서드를 통해 최종적으로 객체를 생성하도록 되어음을 볼수 있다.

사용자

```jsx
public static void main(String[] args) {

    // 생성자 방식
    Hamburger hamburger = new Hamburger(2, 3, 0, 3, 0, 0);

    // 빌더 방식
    Hamburger hamburger = new Hamburger.HamburgerBuilder (2,3)
        .lettuce(3)
        .build();
}
```

빌더 패턴 구조1

```jsx
class Hamburger {
    // 필수 매개변수
    private int bun;
    private int patty;

    // 선택 매개변수
    private int cheese;
    private int lettuce;
    private int tomato;
    private int bacon;
    
    //기본생성자
    private Hamburger (){}
    
    public static class HamburgerBuilder {
	        // 필수 매개변수
			    private int bun;
			    private int patty;
			
			    // 선택 매개변수
			    private int cheese = 0
			    private int lettuce = 0
			    private int tomato = 0
			    private int bacon = 0
       
			    public HamburgerBuilder (int bun , int patty) {
			        this.bun = bun;
							this.patty = patty;
			    }
			
			    public HamburgerBuilder cheese(int cheese) {
			        this.cheese = cheese;
			        return this;
			    }
			
			    public HamburgerBuilder lettuce(int lettuce) {
			        this.lettuce = lettuce;
			        return this;
			    }
			
			    public HamburgerBuilder tomato(int tomato) {
			        this.tomato = tomato;
			        return this;
			    }
			
			    public HamburgerBuilder bacon(int bacon) {
			        this.bacon = bacon;
			        return this;
			    }
	    
			    public PersonInfo build(){
					    Hamburger  hamburger = new Hamburger ();
					    hamburger.bun  = bun **;**
					    hamburger.bun  = patty **;**
					    hamburger.cheese = cheese ;
					    hamburger.lettuce = lettuce;
					    hamburger.tomato = tomato;
					    hamburger.bacon = bacon;
					    					    
					    return hamburger ;
			    }
    
    }
    
    
```

Lombok @Builder

위에서 만든 빌더 클래스를 직접 만들지 않아도 롬복플러그인이 지원해주는 어노테이션 하나로 클래스를 생성할 수 있다.

클래스 또는 생성자 위에 @Builder 어노테이션을 붙여주면 빌더 패턴 코드가 빌드된다.

```jsx
@Builder
class Hamburger {
    // 필수 매개변수
    private int bun;
    private int patty;

    // 선택 매개변수
    private int cheese;
    private int lettuce;
    private int tomato;
    private int bacon;
   }
```

사용자

```jsx
public static void main(String[] args) {

    // 빌더 방식
    Hamburger hamburger = new Hamburger.builder ()
        .bun(2)
        .patty(3)
        .lettuce(3)
        .build();
}
```

매게변수 중 리스트 같은 컬렉션 객체를 빌더 패턴으로 다룰 때 리스트 객체 자체를 넘기는 게 아니라 해당 리스트에 요소를 추가하는 방식으로 생성할 수 있다.

※@Singular 어노테이션이 모든 컬랙션을 다룰수는 없음

```jsx
@Builder
class Hamburger {
    // 필수 매개변수
    private int bun;
    private int patty;

    // 선택 매개변수
    private int cheese;
    private int lettuce;
    private int tomato;
    private int bacon;
    
    //
     @Singular("alias") private List<String> alias;
   }
```

빌더 패턴의 장단점

장점

- 불필요한 생성자의 제거
- 데이터의 순서에 상관없이 객체생성 가능
- 명시적 선언으로 이해하기가 쉽고
- 각 인자가 어떤 의미인지 알기 쉽다.
- setter메서드가 없으므로 변경 불가능한 객체를 만들수있다.
- 한번에 객체를 생성하므로 객체일관성이 깨지지 않는다.
- build()함수가 null인지 체크해주므로 검증이 가능한다.
- 안그러면 set하지않은 객체에대해 get을 하게되는경우 nullPointerExcetpion발생 등등의 문제

단점

- 코드의 복잡성 증가
    - 우선 빌더 패턴을 적용하려면 N개의 클래스에 대해 N개의 새로운 빌더 클래스를 만들어야 해서, 클래수 수가 기하급수적으로 늘어나 관리해야 할 클래스가 많아지고 구조가 복잡해질 수 있다. 또한 선택적 매개변수를 많이 받는 객체를 생성하기 위해서는 먼저 빌더 클래스부터 정의해야한다. 다만 이부분은 여느 디자인 패턴이 가지는 단점이기도 하다.
- 생성자 보다는 성능이 떨어짐
    - 매번 메서드를 호출하여 빌더를 거쳐 인스턴스화 하기 때문에 어쩌면 당연한 말일지도 모른다. 비록 생성 비용 자체는 크지는 않지만, 어플리케이션의 성능을 극으로 중요시되는 상황이라면 문제가 될수 있다.
- **지나친 빌더 남용은 금지**

        - 클래스의 필드의 개수가 4개 보다 적고, 필드의 변경 가능성이 없는 경우라면 차라리 생성자나 정적 팩토리 메소드Visit Website를 이용하는 것이 더 좋을 수 있다. 

           빌더 패턴의 코드가 다소 장황하기 때문이다. 따라서 클래스 필드의 갯수와 필드 변경 가능성을 중점으로 보고 패턴을 적용 유무를 가려야한다.  다만 API 는 시간이 지날수            록 많은 매개변수를 갖는 경향이 있기 때문에 애초에 빌더 패턴으로 시작하는 편이 나을 때가 많다고 말하는 경향도 있다.

참고 자료 출처

1.[https://velog.io/@park2348190/Lombok-Builder의-동작-원리](https://velog.io/@park2348190/Lombok-Builder%EC%9D%98-%EB%8F%99%EC%9E%91-%EC%9B%90%EB%A6%AC)

2.[https://inpa.tistory.com/entry/GOF-💠-빌더Builder-패턴-끝판왕-정리](https://inpa.tistory.com/entry/GOF-%F0%9F%92%A0-%EB%B9%8C%EB%8D%94Builder-%ED%8C%A8%ED%84%B4-%EB%81%9D%ED%8C%90%EC%99%95-%EC%A0%95%EB%A6%AC)

3.https://esoongan.tistory.com/82

1번을 무조건 한번 읽어보기를 추천