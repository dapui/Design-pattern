# 프로토타입

**어떠한 서류가 한 장 더 필요할 때 이를 똑같이 타이핑해서 만드는 것보다 복사를 하는 것이 편하다.**

- 프로토타입 패턴(Prototype Pattern)은 객체를 생성할 때, 기존 객체의 복사를 통해 새로운 객체를 생성하는 디자인 패턴 중 하나입니다. 이는 객체 생성을 위한 복잡한 과정을 간소화하고, 또한 유사한 객체를 생성할 때 객체 생성 시간과 비용을 줄일 수 있는 장점이 있습니다.

- 프로토타입 패턴을 사용하면, 객체 생성 과정에서 복잡한 로직이 필요한 경우, 이미 생성된 객체를 복제(clone)하여 새로운 객체를 생성합니다. 이 때 복제를 통해 생성된 객체를 프로토타입 객체(Prototype)라고 합니다.

- 프로토타입 패턴을 구현할 때는, 복제를 위해 자바에서 제공하는 Cloneable 인터페이스를 구현하고, clone() 메서드를 오버라이드하여 구현합니다.

- 프로토타입 패턴은 객체의 복제를 통해 새로운 객체를 생성하기 때문에, 기존 객체와 새로운 객체가 독립적으로 존재해야 합니다. 이를 위해 프로토타입 객체는 깊은 복사(deep copy) 또는 얕은 복사(shallow copy)를 이용하여 객체를 복제합니다.
    - 얕은복사(shallow copy) : 객체의 필드들을 복제할 때, 참조 타입의 필드는 원본 객체와 복제된 객체가 같은 인스턴스를 참조
        - 얕은복사 유의할 점 : 복사된 객체와 원본 객체가 같은 내부 객체(참조 타입 필드)를 공유하게 되어, 한쪽에서 내부 객체를 변경하면 다른 쪽에도 영향을 미칩니다. 이를 해결하기 위해 **깊은 복사 (Deep Copy)**를 위해 clone() 메서드를 오버라이딩 시 참조 타입 필드를 재귀적으로 복사해야 합니다.
    - 깊은복사(deep copy) : 참조 타입의 필드도 새로운 인스턴스를 생성하여 복제. 즉, 모든 필드 변수들이 새로운 인스턴스를 가짐

- 프로토타입 패턴은 다음과 같은 장점을 가지고 있습니다.
    - 객체 생성 비용과 시간을 줄일 수 있습니다.
    - 새로운 객체를 생성할 때 객체 생성 과정에서 발생할 수 있는 오버헤드를 줄일 수 있습니다.
    - 객체 생성 방법이 복잡하거나 생성할 객체의 타입이 동적으로 결정되는 경우 유용합니다.
    
- 프로토타입 패턴은 다음과 같은 단점을 가지고 있습니다.
    - Cloneable 인터페이스의 한계 : 프로토타입 패턴을 구현하기 위해서는 Cloneable 인터페이스를 필연적으로 사용하게 되는데, 이 인터페이스는 마커(marker) 인터페이스고, clone() 메소드는 얕은 복사만을 수행하기 때문에 깊은 복사를 수행하려면 추가적인 작업이 필요합니다.
        - 마커 인터페이스 : 아무 메서드도 선언되어있지 않고, 단지 자신을 구현하는 클래스가 특정 속성을 가짐을 표시하는 인터페이스
    - 복제 과정의 복잡성 : 객체가 복잡한 구조를 가지거나 참조하는 객체들이 많은 경우, 이를 적절하게 복제하려면 복잡한 복제 과정이 필요할 수 있습니다. 특히, 객체 그래프가 순환이 발생하는 경우에 복제 과정이 더욱 복잡해질 수 있습니다.
        - 순환예시(Employee → Department → Employee (순환))
            
            class Employee {
                private String name;
                private Department department;
            
            *// Employee → Department 관계*
            
            }
            
            class Department {
                private String name;
                private Employee manager;
            
            *// Department → Employee 관계 (순환 참조)*
            
            }
            
    - 메모리 사용량 증가 : 객체를 복제하여 생성하면 메모리 사용량이 증가할 수 있습니다. 특히 객체가 큰 데이터를 가지고 있거나 복제해야 할 객체 수가 많을수록 사용량이 증가합니다.

**!!강조**

**new 키워드를 사용하면 객체가 생성될 때 반드시 생성자가 호출됩니다. 생성자 안에는 필드 초기화, 다른 메서드 호출, 복잡한 비즈니스 로직 등 다양한 초기화 코드가 포함될 수 있으며, 이는 CPU 시간과 메모리 오버헤드를 발생시킵니다.**

**반면, clone() 메서드는 생성자를 전혀 호출하지 않습니다. 대신, 원본 객체에 할당된 메모리 영역을 그대로 복제하여 새 객체를 생성합니다. 이로 인해 초기화 오버헤드를 완전히 피할 수 있습니다.**

| **특징** | **new 키워드** | **clone() 메서드** |
| --- | --- | --- |
| **목적** | **새로운 객체**를 완전히 **처음부터 생성**합니다. | **기존 객체의 복사본**을 생성합니다. |
| **생성 과정** | 클래스 로딩, 메모리 할당, **생성자 호출**을 거칩니다. | 메모리 할당 후, **필드 값을 복사**하고 생성자는 **호출하지 않습니다**. |
| **Deep Copy / Shallow Copy** | 해당 사항 없음 (항상 새로운 객체) | 기본적으로 **얕은 복사(Shallow Copy)**를 수행합니다. (참조 타입 필드는 주소만 복사) |
| **메모리 할당** | 처음부터 새롭게 메모리를 할당합니다. | 기존 객체의 필드 값을 복사하는 과정에서 **더 빠를 수 있습니다.** |
| **예외 처리** | 생성자에서 예외가 발생할 수 있습니다. | `CloneNotSupportedException`을 처리해야 합니다. |
| **구현 필요성** | 필요 없음 (언어 기본 키워드) | 클래스가 `Cloneable` 인터페이스를 구현하고 `clone()`을 **오버라이딩**해야 합니다. |