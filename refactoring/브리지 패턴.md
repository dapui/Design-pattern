# 브리지(Bridge) 패턴

<aside>

💡"기능"과 "구현"을 분리해서 각각 독립적으로 확장할 수 있게 만드는 패턴

"제어하는 부분(GUI)과 실제 일하는 부분(API)을 분리해서, 서로 영향 없이 각자 발전시키자!”

</aside>

## **기존 방식의 문제점**

```markdown
Shape
├── Circle
│   ├── RedCircle
│   └── BlueCircle
└── Square
    ├── RedSquare
    └── BlueSquare
```

- 삼각형을 추가하면? → RedTriangle, BlueTriangle 2개 추가
- 초록색을 추가하면? → GreenCircle, GreenSquare, GreenTriangle 3개 추가
- **조합이 늘어날수록 클래스가 폭발적으로 증가!**

## 브리지 패턴의 해결책

두 개의 독립적인 계층으로 분리

```
Shape (모양) ─────→ Color (색상)
├── Circle          ├── Red
└── Square          └── Blue
```

**핵심**: Shape가 Color 객체를 **참조**하도록 만듭니다.

코드 예시

```java
// 구현부 (색상)
interface Color {
    void applyColor();
}

class Red implements Color {
    void applyColor() { 
        System.out.println("빨간색 적용"); 
    }
}

class Blue implements Color {
    void applyColor() { 
        System.out.println("파란색 적용"); 
    }
}

// 추상부 (모양)
abstract class Shape {
    protected Color color;  // ← 브리지!
    
    Shape(Color color) {
        this.color = color;
    }
    
    abstract void draw();
}

class Circle extends Shape {
    Circle(Color color) {
        super(color);
    }
    
    void draw() {
        System.out.print("원 그리기 - ");
        color.applyColor();  // 색상 작업 위임
    }
}

// 사용
Shape redCircle = new Circle(new Red());
redCircle.draw();  // "원 그리기 - 빨간색 적용"
```

## 장점

1. **확장성**: 모양 추가 시 색상 코드 수정 불필요, 색상 추가 시 모양 코드 수정 불필요
2. **클래스 수 감소**: 모양 3개 × 색상 3개 = 9개 클래스 → 모양 3개 + 색상 3개 = 6개 클래스
3. **유연성**: 실행 중에도 색상 변경 가능
4. **테스트와 유지보수 쉬움**: 작은 모듈 단위로 이해 가능

## 한 줄 요약

**"상속으로 조합하지 말고, 참조로 연결해서 각각 독립적으로 확장하자!"**

---

# 추상화와 구현

앱 개발 상황

```
[추상화] GUI (사용자 인터페이스)
   ↓ 명령 전달
[구현] OS API (실제 작업 수행)
```

**예시**:

- **추상화**: "파일 저장" 버튼을 누름 (GUI)
    - **사용자가 보는 쪽, 또는 상위에서 흐름을 제어하는 역할**
        - “무엇을 할지”를 결정
        - “어떻게 할지”는 직접 처리하지 않음
        - 실제 일은 구현에게 맡김
- **구현**: 윈도우/맥/리눅스 각각의 방식으로 실제 파일 저장 (OS API)
    - 실제 일을 수행하는 쪽, 구체적인 동작을 담당하는 역할
        - “어떻게 할지”를 알고 있음
        - 상위 제어 흐름은 모름

> 브리지 패턴에서 말하는 추상화는 ‘상위에서 흐름을 제어하는 역할’이고, 구현은 ‘실제 일을 처리하는 역할’이다.
> 

## 브리지 패턴 없이 개발하면?

스파게티 코드의 탄생 (**스파게티 코드** = 코드의 흐름이 복잡하게 얽혀있어서 이해하고 수정하기 어려운 코드)

```java
// 나쁜 예: 모든 조합을 if문으로 처리
class App {
    void saveFile() {
        if (isAdminUI && isWindows) {
            // 관리자용 윈도우 저장 로직
        } else if (isAdminUI && isMac) {
            // 관리자용 맥 저장 로직
        } else if (isUserUI && isWindows) {
            // 일반 사용자용 윈도우 저장 로직
        } else if (isUserUI && isMac) {
            // 일반 사용자용 맥 저장 로직
        }
        // ... 계속 늘어남
    }
}
```

**문제점**:

- GUI 2개 × OS 3개 = 조건문 6개
- GUI 추가 → 모든 OS별 코드 추가
- OS 추가 → 모든 GUI별 코드 추가
- **코드 전체를 이해해야만 수정 가능!**

## 브리지 패턴으로 해결

두 계층으로 분리

```java
// [구현 계층] - OS API
interface OSApi {
    void saveFile(String data);
}

class WindowsAPI implements OSApi {
    void saveFile(String data) {
        System.out.println("윈도우 방식으로 저장: " + data);
    }
}

class MacAPI implements OSApi {
    void saveFile(String data) {
        System.out.println("맥 방식으로 저장: " + data);
    }
}

class LinuxAPI implements OSApi {
    void saveFile(String data) {
        System.out.println("리눅스 방식으로 저장: " + data);
    }
}

// [추상화 계층] - GUI
abstract class Application {
    protected OSApi osApi;  // ← 브리지! (상속하지 않고 필드로 가지고 있음 - Application은 OS에 의존하지만, 어떤 OS인지는 모른다)
    
    Application(OSApi osApi) {
        this.osApi = osApi; // 실행 시점에 어떤 OS 구현체를 쓸지 결정
    }
    
    abstract void save(); // “저장한다”라는 의도만 정의: 실제 저장 방법은 하위 클래스 + OSApi에 위임
}

/*
 * 역할 분리 핵심 포인트
 * UI/업무 흐름 → AdminApp (AdminApp은 OS가 Windows인지 Mac인지 전혀 모름)
 * 실제 파일 저장 → OSApi (같은 OSApi를 쓰더라도 앱의 성격(UI/데이터)은 완전히 다르게 동작)
 */

class AdminApp extends Application {
    AdminApp(OSApi osApi) {
        super(osApi);
    }
    
    void save() {
        System.out.println("[관리자 UI] 파일 저장 시작");
        osApi.saveFile("관리자 데이터");  // 실제 작업 위임
    }
}

class UserApp extends Application {
    UserApp(OSApi osApi) {
        super(osApi);
    }
    
    void save() {
        System.out.println("[사용자 UI] 파일 저장 시작");
        osApi.saveFile("사용자 데이터");  // 실제 작업 위임
    }
}
```

사용 예시

```java
// 윈도우용 관리자 앱
Application adminWin = new AdminApp(new WindowsAPI());
adminWin.save();

// 맥용 사용자 앱
Application userMac = new UserApp(new MacAPI());
userMac.save();
```

**UI(Application 계층)** 와 **OS별 파일 저장 로직(OSApi 계층)** 을 **상속이 아니라 조합으로 연결해서** 서로 독립적으로 확장 가능하게 만든 구조

- 브리지(Bridge) 패턴은 “상속으로 얽히는 구조”를 버리고, 조합(Composition)으로 연결해서 두 축을 서로 독립적으로 확장 가능하게 만든 패턴
- “서로 다른 변화 이유를 가진 것들을 상속으로 묶지 말고 조합으로 분리하는 패턴”
- 브리지 패턴은 ‘상속 트리가 가로 × 세로로 커지기 시작할 때’ 그 트리를 잘라서 다리로 연결하는 패턴이다

브리지 패턴 UML 다이어그램

```
        <<Abstraction>>
        Application
        ------------------
        - osApi : OSApi
        ------------------
        + save()

              ▲
              │
    -------------------------
    │                       │
<<Refined>>           <<Refined>>
 AdminApp               UserApp
 --------               --------
 + save()               + save()

        <<Implementor>>
        OSApi
        ------------------
        + saveFile(data)

              ▲
              │
    -------------------------
    │                       │
<<Concrete>>          <<Concrete>>
 WindowsOSApi           MacOSApi
 ------------           ----------
 + saveFile()           + saveFile()

```

Application과 OSApi는 **각자 상속 트리를 가진다**

그리고 그 둘은 서로 **직접 의존하지 않는다**

### 1. 핵심 장점

- 새 GUI 추가 (태블릿용) → OS API 코드 수정 불필요
- 새 OS 추가 (안드로이드) → GUI 코드 수정 불필요

✅ **확장에 열려 있음 (OCP)**

- 새로운 OS 추가 → `OSApi` 구현체만 추가
- 새로운 앱 추가 → `Application` 하위 클래스만 추가
- **기존 코드 수정 없이 기능 확장 가능 (**서로 **영향 없음)**

✅ **이 코드의 진짜 핵심**

Application은 무엇을 할지만 알고, OSApi는 어떻게 할지만 안다. 그리고 둘은 브리지로 연결되어 있다

### 2. 클래스 개수 비교

- **분리 전**: GUI 2개 × OS 3개 = **6개 클래스**
- **분리 후**: GUI 2개 + OS 3개 = **5개 클래스**
- OS/GUI 추가 시에도 단 1개씩만 증가!

### 3. 코드 이해도

- **분리 전**: 전체 코드를 봐야 수정 가능
- **분리 후**: 해당 클래스만 보면 됨 (모듈화)

---

## **“브리지가 없을 때 흔히 빠지는 최악의 구조”**

### 상속 이전 단계

**상속조차 안 쓰고**, **조건문(if-else)으로 모든 경우의 수를 한 클래스에 몰아넣은 상태**

```java
class App {
    void saveFile() {
        if (isAdminUI && isWindows) {
            ...
        } else if (isAdminUI && isMac) {
            ...
        } else if (isUserUI && isWindows) {
            ...
        } else if (isUserUI && isMac) {
            ...
        }
    }
}
```

### 이 구조의 본질적인 문제

- 역할이 **하나도 분리되지 않음**
- UI 변경 + OS 변경 + 저장 로직 변경이 전부 한 곳에 섞임
- 새로운 조합 추가 시 **조건문 폭발**

### “상속으로 해결하려다 망하는” 전형적인 구조

조건문이 싫어서 사람들이 보통 이렇게 바꿈

```java
abstract class App {
    abstract void saveFile();
}

class WindowsAdminApp extends App { ... }
class MacAdminApp extends App { ... }
class WindowsUserApp extends App { ... }
class MacUserApp extends App { ... }

```

### 여기서 생기는 문제

- UI 종류 × OS 종류 = 클래스 개수
- OS 하나 추가 → 모든 UI에 대해 클래스 추가
- UI 하나 추가 → 모든 OS에 대해 클래스 추가

**상속이 문제라기보다, “두 개의 변화 축을 하나의 상속 트리에 묶은 것”이 문제**

---

## 브리지 패턴을 쓰면 **과한 설계가 되는 경우**

⚠️ 브리지는 **만능 패턴이 아님**.

① 변화 축이 **하나뿐일 때**

```java
class App {
    void save() {
        // OS별 분기만 있음
    }
}
```

- UI는 하나뿐 (admin 없이 user용 ex.소개용 홈페이지 등)
    - [https://www.wbsoft.kr/](https://www.wbsoft.kr/intro)
    - [https://www.subway.co.kr/](https://www.subway.co.kr/)
- OS만 바뀜

👉 이럴 때 브리지 쓰면?

- 인터페이스
- 추상 클래스
- 구현체
    
    → **쪼갠 만큼 얻는 게 없음**
    

✅ 그냥 Strategy나 if 분기면 충분

```java
// UI는 1개, OS만 3개인 경우

// 브리지 패턴 (과함!)
interface OSApi {
    void render();
}

class WindowsAPI implements OSApi { }
class MacAPI implements OSApi { }
class LinuxAPI implements OSApi { }

abstract class Application {
    protected OSApi osApi;  // ← 불필요한 복잡성
}

class LandingPage extends Application {  // ← 상속할 필요 없음
    // 어차피 LandingPage 하나밖에 없는데...
}
```

② 조합의 경우의 수가 **거의 안 늘어날 때**

```
AdminApp + Windows
UserApp  + Windows
```

- Mac 지원 예정 없음
- UI도 1~2개에서 끝

👉 “혹시 나중에 늘어날 수도…” 수준이면

❌ **미리 브리지 만들면 과설계**

---

## ✅ 브리지 패턴이 “딱 맞는” 신호들

### ✔️ 신호 1

> “이거… UI도 계속 늘고
> 
> 
> OS / 플랫폼도 계속 늘어날 것 같은데?”
> 

### ✔️ 신호 2

> “상속 트리가 가로 × 세로로 커지고 있다”
> 

```
Admin × Windows
Admin × Mac
Admin × Linux
User  × Windows
User  × Mac
User  × Linux
```

### ✔️ 신호 3

> “테스트할 때 OS만 갈아끼우고 싶다”
> 

```java
Application app =
    new AdminApp(new MockOSApi());
```

브리지는 ‘지금 복잡해서 쓰는 패턴’이 아니라 ‘곧 폭발할 구조를 미리 잘라내는 패턴’이다

---

## 브리지 패턴 실전 사례

브리지는 **“플랫폼 / 환경 / 표현”이 갈라지는 곳**에서 진짜 강력

### ✅ 사례 1: 데스크톱/모바일 앱 + OS

**문제 상황**

- 관리자 앱 / 사용자 앱
- Windows / macOS / Linux
- 모바일까지 확장 예정

```java
abstract class App {
    protected Platform platform;
}

class AdminApp extends App { ... }
class UserApp extends App { ... }

interface Platform {
    void saveFile(String data);
}

class WindowsPlatform implements Platform { ... }
class MacPlatform implements Platform { ... }
```

### ✅ 사례 2: UI 프레임워크 (실제 라이브러리 구조)

예: UI 컴포넌트

```markdown
Button
 ├─ WindowsButton
 ├─ MacButton
 └─ LinuxButton
```

❌ 이렇게 만들면 UI × OS 폭발

**브리지 방식**

```java
abstract class Button {
    protected Renderer renderer;
}

interface Renderer {
    void drawButton();
}
```

- `Button` → UI 개념
- `Renderer` → 플랫폼별 렌더링

### ✅ 사례 3: 로그 시스템 (실무에서 자주 씀)

**요구사항**

- 로그 종류: `AuditLog`, `ErrorLog`, `AccessLog`
- 출력 방식: `File`, `DB`, `Kafka`, `Slack`

```java
abstract class Log {
    protected LogWriter writer;
}

interface LogWriter {
    void write(String msg);
}
```

👉 로그 종류 늘어도 OK

👉 저장 방식 늘어도 OK

### ✅ 사례 4: 결제 앱 (Strategy + Bridge 조합)

> 실무에서는 단독으로보다 조합해서 씀
> 
- Bridge → 플랫폼 분리 (웹 / 앱)
- Strategy → 결제 수단 (카드 / 계좌 / 간편결제)

```markdown
PaymentApp ── Bridge ──▶ Platform
              |
              └─ Strategy ──▶ PaymentMethod
```

---

# Bridge vs Strategy

### 🔹 핵심 차이 한 문장

| 패턴 | 한 문장 요약 |
| --- | --- |
| **Bridge** | **구조 자체를 분리**해서 *두 축을 독립적으로 확장* |
| **Strategy** | **알고리즘을 교체**해서 *행위를 바꾼다* |

### 🔹 구조 차이

**Bridge 구조**

```markdown
Abstraction ────▶ Implementor
     ▲                 ▲
 Refined          Concrete
```

- **상속 트리를 쪼개는 패턴**
- “UI 축” vs “플랫폼 축”

```java
// 두 계층 모두 확장됨
abstract class Application {
    protected OSApi osApi;  // ← 브리지
}
class AdminApp extends Application { }     // ← 추상화 확장
class UserApp extends Application { }      // ← 추상화 확장

class WindowsAPI implements OSApi { }      // ← 구현 확장
class MacAPI implements OSApi { }          // ← 구현 확장
```

**Strategy 구조**

```java
Context ────▶ Strategy
                  ▲
           ConcreteStrategy
```

- **알고리즘을 갈아끼우는 패턴 (**어떤 전략을 쓸지 **선택하고 교체** 가능)
- “이 일을 *어떻게* 할지”

```java
// Context는 1개, Strategy만 확장됨
class ShoppingCart {                       // ← 확장 안 함
    private PaymentStrategy strategy;
}

class CreditCard implements PaymentStrategy { }  // ← 전략만 확장
class KakaoPay implements PaymentStrategy { }    // ← 전략만 확장
```

### 🔹 코드 차이 (감각용)

Bridge 느낌

```java
Application app = new AdminApp(new WindowsOSApi());
```

> “이 앱 + 이 플랫폼”
> 

Strategy 느낌

```java
PaymentService service = new PaymentService(new CardPayment());
```

> “이 로직 + 이 전략”
> 

## 🔹 실무에서 자주 하는 실수

❌ “인터페이스 있으면 다 Strategy 아님?”

👉 **아님**

- 구조를 쪼갰으면 → Bridge
- 행동만 바꿨으면 → Strategy

> Bridge는 ‘클래스 구조 문제’
Strategy는 ‘행동 선택 문제’
>
